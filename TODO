

Current:

	
	☐ Browser: Treeview context menu functionality: hud descriptions (gui images get garbage collected or something)
	☐ Browser: Treeview context menu functionality: integers
	☐ Browser: Treeview context menu functionality: treeview_recycle

	☐ Browser: Treeview context menu toggle entries based on availablility? eg. default item might not be available
	☐ Browser: Treeview header sorting

Features:
	☐ Add all functionality of the start gui into the editor menu. Remaining: Create/Add hud & dev options menu
Bugs:
	
GUI:
	☐ Browser: Display custom and 'added-to-hud' status for files in the browser (Consider adding columns or a status ba)
	☐ Menu: Add icons
	☐ Installer: Incorporate progress GUI for the installer class. Install/update/repair/delete

	☐ Refactor: GUI: Base GUI class with common functionality for all other gui's to use
		☐ Bug: GUI: I can use show() method for my gui without first having ran the gui's mainloop with run()

	☐ Refactor: Start GUI. Messageboxes for dev menu results

Unit Testing:
	☐ Unit test: HudDescriptions

Refactoring:
	☐ Refactor: I'm passing my persistent_data object absolutely everywhere. Create a persistent_data class singleton instead
	
	
	☐ Sync: Refactor(?)
	☐ Refactor GameDir: A bunch of duplicate code related to methods like: get_main_dir_backup, get_main_dir_backup_materials
	☐ Refactor GameDir: Ensure functions like get_main_dir_backup, get_main_dir_backup_materials are used throughout the codebase
	☐ Refactor GameDir: should get_main_dir_backup check if the directory is valid? or in the code that uses it
	☐ Refactor ID handler: Should i combine the manual selecting of ID path into the get/set functions?
		- That would simplify some code paths: -- although it seems like that would maybe defeat the single purpose principle?
		# get user directory
		if not self.game.dir.get(DirectoryMode.USER)
			try
				self.game.dir.id.set_id_path(DirectoryMode.USER)
			except Exception as err_info
				show_message(f"{err_info}", "error", 'Could not get user directory!')
				return False

	☐ Refactor: hud class. Some notes: start_editing has confusing checks like:
		if self.syncer.get_sync_status() and self.syncer.get_source_dir() == self.hud_dir and sync_hud

	☐ Refactor: ID handler: Consider simpler names? eg: game.dir.id.set_id_path could maybe be just id.set()
	☐ Refactor: descriptions: Pretty sure it could/should use my general functions for loading/saving data
	☐ Refactor: loading/saving data: confirm throughout the script json reading/writing is done by the same funcs
	☐ Refactor: installer's install() repair() update() have a lot of duplicate code
	☐ Private and internal classes dont need param checking, only public
	☐ Handle VPK class failing to extract specific files during installation
	☐ Make internal class methods protected by adding underscores. And internal with double __
	☐ Add dir_mode enum checks to game class?
	☐ Utilize exception handling for specific cases like AssertionError and ValueError
	☐ Simplify manager class, improve 'get_dir' function and other enhancements
	☐ Enums. For example for steam_info object (?) or make it into a class
	☐ Replace assert statements with proper error handling using try/catch
	☐ Use Super(). This can elimiate the need to for example define self.persistent_data again in subclasses
	☐ self.game.run("dev", "wait on close") -> wait_on_close=True/False
	☐ Make the function to create lambda commands a shared utility, and use it in the project
	☐ Streamline and test HUD editing process for improved code path
	
	☐ Explore restructuring options for more efficient code flow
	☐ Evaluate the use of singleton patterns in GUI management
	☐ Break up the game commands execute method for better organization
	☐ Consider alternatives for using subclasses and direct referencing
	☐ Reevaluate the use of persistent_data in classes, possibly with a dedicated class or alternative approach
	☐ Optimize and improve functions, methods, and overall structure based on GPT suggestions
	☐ Installer: Add try&except for validate_mode_parameter calls with custom invalid mode param exception to catch
		☐ Determine what should happen for each instance

Additional Ideas and Considerations:
	☐ Global hotkey management: Explore using a global singleton hotkey manager to streamline hotkey handling
	☐ Editor menu: Add all start GUI functionality. We're almost there already.
		☐ Use the relevant menu's from the editor menu in start to prevent duplication
	☐ Multi-game support: Explore multi-game support feasibility
	☐ Command line: Evaluate potential of using command line interface instead of GUI
	☐ Pull some workshop map off of steam to use for L4D2. And possibly a map for L4D1
	☐ Idea: Use threading GUI during lengthy operations such as shutil.rmtree during installation  (Adds complexity)

	☐ Idea: Already tried this for an hour. But a way to retrieve the OS's default icon for a file path to be used in the treeview
	☐ Bug: Currently the game gets bound to the python process, and also closes if the script closes @impossible?
		- Seemingly impossible although apparently it is possible: Run a process detached from python
		- Note: Running the game before starting the editor works fine.
			- so could use a script to launch it and then the editor
		- I was able to get it to work with notepad.exe using subprocess start /B notepad.exe,
		- however that didn't work for the game or steam
		- this is legitimately around 2 hours of trail and error:
		# Use subprocess.Popen with DETACHED_PROCESS flag
        # result = subprocess.Popen(steam_command, shell=True)
        # result = subprocess.Popen([steam_command], shell=True)
        # result = subprocess.run(steam_command, shell=True, check=True)
        # result = subprocess.run([steam_command], shell=True, check=True)
        # result = subprocess.Popen(steam_command, shell=False, creationflags=subprocess.DETACHED_PROCESS)
        # result = subprocess.Popen([steam_command], shell=False, creationflags=subprocess.DETACHED_PROCESS)
        # result = subprocess.Popen(["start", "/B", steam_command], shell=True)
        # result = subprocess.Popen(["cmd", "/c", steam_command])
        # os.system(steam_command)

        # detached_process_flag = 0x00000008  # Constant for creating a detached process
        # subprocess.Popen(
        #     steam_command,
        #     shell=True,
        #     creationflags=detached_process_flag,
        #     start_new_session=True,  # Required for some platforms
        # )

        # ahk_script = f"Run cmd.exe /c del {steam_command}"
        # steam_command_cmd = f'{steam_exe} {steam_args} {" ".join(game_args)}'
        # steam_command_cmd_quoted = f'"{steam_exe} {steam_args} {" ".join(game_args)}"'
        # steam_command_quoted = f'"{steam_command}"'
        # pristine_command = f'{steam_exe}'
        # print(f"steam command cmd: {steam_command_cmd}")
        # print(f"steam command cmd quoted: {steam_command_cmd_quoted}")
        # print(f"steam command: {steam_command}")
        # print(f"steam command quoted: {steam_command_quoted}")
        # ahk_script = f"Run cmd.exe /k del {steam_command_cmd_quoted}"
        # ahk_script = "run cmd /k E:\games\steam\steam.exe -applaunch 550 -novid -console"
        # ahk_script = f"run cmd /k {pristine_command} {steam_args}"
        # ahk_script = f"run {pristine_command} {steam_args}"
        # print(ahk_script)
        # ahk.run_script(ahk_script, blocking=False)

        # print(self.game.steam.get_exe_path())
        # subprocess.Popen(["rm", "-r", self.game.steam.get_exe_path()])

        # subprocess.Popen(['python', os.path.realpath(__file__), '0'], close_fds=True)
        # print(f'file =================================== {os.path.realpath(__file__)}')
        # subprocess.Popen(["python", self.game.steam.get_exe_path(), "0"], close_fds=True)

        # DETACHED_PROCESS = 0x00000008

        # pid = subprocess.Popen([sys.executable, "longtask.py"], creationflags=DETACHED_PROCESS).pid

        # import subprocess

        # subprocess.Popen(["notepad.exe", "test.txt"])

        # command = "longtask.py &"
        # subprocess.Popen(command, shell=True)

        # command = "start /B notepad.exe"
        # subprocess.Popen(command, shell=True)

        # command = f"start /B {self.game.steam.get_exe_path()}"
        # subprocess.Popen(command, shell=True)






















--Archive--:
✔ Browser: Treeview context menu functionality @started(23-08-20 14:15) @done(23-08-20 15:10) @lasted(55m38s)
✔ Browser: Treeview menu icons @done(23-08-20 14:09)
✔ General: Add icon buttons to all GUI's @started(23-08-20 11:34) @done(23-08-20 11:35) @lasted(1m8s)
✔ General: Create custom app.ico @done(23-08-20 11:10)
✔ General: Add icons to all GUI's @done(23-08-20 11:03)
✔ Bug: Browser has a visual glitch when starting up. Shows and disappears within a second @done(23-08-20 11:03)
✔ Remove duplicate code in hud.py related to GuiHudStart instance creation @done(23-08-20 10:38) show_start_gui()
✔ Testing: Create test for syncer @done(23-08-20 10:29)
✔ Am I using too many exceptions? When should i return a (None) value instead @done(23-08-20 10:28)

✘ Bug: Different separators in is_subdirectory even after trying various normpath solutions @low @cancelled(23-08-20 10:24)
✔ Investigate console errors for failing to load maps @done(23-08-20 10:21) config appending instead of rewriting the editor autoexec

✔ Address in-game console bugs related to malformed VPK addons loading @done(23-08-20 10:20) using tiny valid vpk's
✔ Fix 'added' files option not working in treeview, no data retrieved @done(23-08-20 10:20)	
✔ Bug: Addon title for the debug hud was not retrieved @done(23-08-20 10:16)
✔ Bug: Addontitle: Exception with invalid format of the addoninfo.txt text file @done(23-08-20 10:16)

✔ Instead of using game.dir.get create game.installed()? @done(23-08-20 09:52)
✔ Issue i got personally confused that i should be using self.game.dir.get(DirectoryMode.USER) to check if dev exists @done(23-08-20 09:41)
✘ Bug: ID handler: Calling ID handler without a dir_mode doesn't raise an error! also check for sync and other methods 'gamez.dir.id.get_installation_state' @cancelled(23-08-20 09:40) (Can't actually do anything with this. Just fix invalid method call)	
✔ Retrieving installation state for mode that isn't installed returns UNKNOWN should it be UNAVAILABLE or just None instead? @done(23-08-20 09:38)	
✔ Bug: ID handler: User dev mode is installed -> Get installation state -> Exception has occurred: KeyError @started(23-08-20 08:53) @done(23-08-20 09:10) @lasted(17m53s)
	- Get installation state was using the SyncState enum!
✔ Test: Sync: restore_developer_directory @done(23-08-20 00:20)
✔ Sync: Make use of the SyncState enum in the sync class. and in the rest of the script if relevant + modify test @high @done(23-08-19 23:00)
✔ Sync: Refine error handling strategy in sync class @done(23-08-20 00:18)
✔ Sync: Cleanup test @done(23-08-19 22:43)
✔ Handle script closure to ensure unsyncing even during crashes or failures @critical @started(23-08-17 12:04) @done(23-08-19 22:43) @lasted(2d10h39m43s)
✔ Bad unsync detection: Keep track of sync status in the ID file @done(23-08-17 11:55)
✔ Installation class: Maintain a backup of key directories @done(23-08-17 11:56)
✔ When should i check for bad unsync & fix it? Maybe hud.start_editing @started(23-08-17 12:04) @done(23-08-17 13:34) @lasted(1h30m4s)
✔ Write code to fix bad unsynx @done(23-08-17 13:34)

✔ Installer: Keep track of installation status @done(23-08-12 17:17)
✔ Use InvalidIDError @done(23-08-12 15:55)
✔ Use dir_mode & installation status enum's throughout the game manager @done(23-08-12 15:55)

✔ minor refactor: I'm passing self to the game subclasses, but since singleton im pretty sure i don't need to @low @done(23-08-17 11:53)
✔ ^ yes this is needed to avoid important recursion @done(23-08-17 11:53)


✔ Rewrite from first principles @done(23-08-16 06:00)

✔ Write dir class @done(23-08-15 20:10)
✔ Test dir class @done(23-08-15 20:10)
✔ Write installer class @started(23-08-15 23:54) @done(23-08-16 06:00) @lasted(6h6m51s)
	✔ Write .run() & test syntax used in installer: .run(mode, wait_on_close=True) @done(23-08-16 02:39)
	✔ Refactor: wait_on_process_and_get_hwnd // probably/maybe split into 2 funcs? @done(23-08-16 02:41)
	✔ Test installer class @done(23-08-16 02:42)
	✘ Game: Still allow enabling of user mode or dev mode when the other isn't available(?) @cancelled(23-08-16 02:50)
	Nuh-uh. I need to have access to both game folders
	
	✔ Write uninstall() @done(23-08-16 03:28)
	✔ Bug: Game doesn't rebuild audio @done(23-08-16 04:27)
	✔ Bug: Editor autoexec gets appended to rather than replaced @done(23-08-16 04:27)
	✘ Installer: uninstall() when install gets cancelled or otherwise fails @cancelled(23-08-16 04:36)
	✔ Write update/repair() @done(23-08-16 04:40)
	✘ Refactor: install/update/repair has so much duplicate code! @cancelled(23-08-16 04:57)
	✔ Installer: Re-enable prompts & checks in install() & try:catch @done(23-08-16 04:58)
	
	✔ Implementation: Prompt to manually set the dev directory in hud_editing.start @done(23-08-16 05:02)
	
	✔ Write commands class @done(23-08-16 05:35)
	✔ Test commands class @done(23-08-16 05:35)
	
	✔ Centralize video settings calls into a general function @done(23-08-16 06:00)
	✔ Implementation: Replace & delete the old game instance @done(23-08-16 06:00)

