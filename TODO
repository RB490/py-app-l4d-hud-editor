Features:
	Sync:
		

		☐ minor refactor: I'm passing self to the game subclasses, but since singleton im pretty sure i don't need to @low
		
		Sync:
			☐ Sync: Debugging -> Refactor debugging files
			☐ Sync: Debugging -> Tiny hud with all the possible features to (unit) test with
			☐ Refactor: Make use of the SyncState enum in the sync class. and in the rest of the script if relevant @high 
			☐ Sync: Handle script closure to ensure unsyncing even during crashes or failures @critical
				- Bad unsync detection: Keep track of sync status in the ID file
				- Fixing unsync's
					- Simple & faster solution:
						- every file that i sync to the game folder, i also sync to a designated temporary sync folder
						- keep track in the ID file which folder this is probably? as i would create a temp dir and save it there
						- 1. first loop all the files in the unsync folder 2. loop the unsync dirs and only delete if empty
							- ^ but how would i know if a file is custom
					- Simple & great solution (could be a little slow) // actually, no, just materials & resource =1,5gb :
						- During installation process create a backup of the main directory
						- If the script detects that it failed to unsync somehow - delete the entire main dir and restore from backup
							- Detection could work in many ways. Probably simply another ID file. or even the same ID file
			☐ Sync: Refine error handling strategy in sync class(?) possibly during unit testing @high
			os.move error could happen if for example a file in the game dir is locked because in use
			☐ Sync: Review and enhance target directory validation in sync() @high

	ID:
		☐ Refactor: Consider simpler names? eg: game.dir.id.set_id_path could maybe be just id.set()

	General:

Bugs:
	☐ Resolve GUI hanging when running lengthy tasks like uninstalling dev folder
	☐ Fix 'added' files option not working in treeview, no data retrieved
	☐ Address in-game console bugs related to malformed VPK addons loading
		☐ Explore potential fixes, e.g., creating small VPK to overwrite malformed ones
	☐ Investigate console errors for failing to load maps
	☐ Bug: Different separators in is_subdirectory even after trying various normpath solutions @low
	parent: E:\games\steam\steamapps\common
	child: E:/Games/Steam/steamapps/common/Left 4 Dead 2
	output: E:/Games/Steam/steamapps/common/Left 4 Dead 2 is not subdirectory of E:\games\steam\steamapps\common

GUI:
	☐ Add context menu functionality for treeview in browser
	☐ Add icons to enhance GUI aesthetics
	☐ Incorporate progress GUI for the installer class
		☐ Implement for install, update_or_repair, and remove operations
	☐ Menu: Add icons
	☐ Add GUI icons
	☐ Add GUI button icons
	☐ Display custom and added-to-hud status for files in the browser
		☐ Consider adding columns or a status bar
	☐ Enhance context menu icons in the treeview

Unit Testing:
	☐ Create test classes for HUD descriptions(?) and definetly HUD syncer
	☐ Test all menu options for robustness

Refactoring:
	Exceptions and Returns:
		☐ Am I using too many exceptions? When should i return a (None) value instead
			Consider code paths. For example retrieving the steam game dir is vital,
			if that fails. the program should raise an exception, then maybe catch it
			and display it in a messagebox. or display the message box inside the class?
	☐ Refactor: Start GUI
	☐ Refactor: installer's install() repair() update() have a lot of duplicate code
	☐ Private and internal classes dont need param checking, only public
	☐ Handle VPK class failing to extract specific files during installation
	☐ Make internal class methods protected by adding underscores. And internal with double __
	☐ Add dir_mode enum checks to game class?
	☐ Remove duplicate code in hud.py related to GuiHudStart instance creation
		☐ Automatically detect and refactor
	☐ Utilize exception handling for specific cases like AssertionError and ValueError
	☐ Simplify manager class, improve 'get_dir' function and other enhancements
	☐ Enums. For example for steam_info object (?) or make it into a class
	☐ Replace assert statements with proper error handling using try/catch
	☐ Use Super(). This can elimiate the need to for example define self.persistent_data again in subclasses
	☐ self.game.run("dev", "wait on close") -> wait_on_close=True/False
	☐ Make the function to create lambda commands a shared utility, and use it in the project
	☐ Streamline and test HUD editing process for improved code path
	☐ Consider simplifying main GUI by integrating its functionality into menu class
	☐ Explore restructuring options for more efficient code flow
	☐ Evaluate the use of singleton patterns in GUI management
	☐ Break up the game commands execute method for better organization
	☐ Consider alternatives for using subclasses and direct referencing
	☐ Reevaluate the use of persistent_data in classes, possibly with a dedicated class or alternative approach
	☐ Optimize and improve functions, methods, and overall structure based on GPT suggestions
	☐ Installer: Add try&except for validate_mode_parameter calls with custom invalid mode param exception to catch
		☐ Determine what should happen for each instance

Additional Ideas and Considerations:
	☐ Global hotkey management: Explore using a global singleton hotkey manager to streamline hotkey handling
	☐ Editor menu: Add all start GUI functionality. We're almost there already.
		☐ Use the relevant menu's from the editor menu in start to prevent duplication
	☐ Multi-game support: Explore multi-game support feasibility
	☐ Command line: Evaluate potential of using command line interface instead of GUI
	☐ Pull some workshop map off of steam to use for L4D2. And possibly a map for L4D1

	☐ Bug: Currently the game gets bound to the python process, and also closes if the script closes @impossible?
		- Seemingly impossible although apparently it is possible: Run a process detached from python
		- Note: Running the game before starting the editor works fine.
			- so could use a script to launch it and then the editor
		- I was able to get it to work with notepad.exe using subprocess start /B notepad.exe,
		- however that didn't work for the game or steam
		- this is legitimately around 2 hours of trail and error:
		# Use subprocess.Popen with DETACHED_PROCESS flag
        # result = subprocess.Popen(steam_command, shell=True)
        # result = subprocess.Popen([steam_command], shell=True)
        # result = subprocess.run(steam_command, shell=True, check=True)
        # result = subprocess.run([steam_command], shell=True, check=True)
        # result = subprocess.Popen(steam_command, shell=False, creationflags=subprocess.DETACHED_PROCESS)
        # result = subprocess.Popen([steam_command], shell=False, creationflags=subprocess.DETACHED_PROCESS)
        # result = subprocess.Popen(["start", "/B", steam_command], shell=True)
        # result = subprocess.Popen(["cmd", "/c", steam_command])
        # os.system(steam_command)

        # detached_process_flag = 0x00000008  # Constant for creating a detached process
        # subprocess.Popen(
        #     steam_command,
        #     shell=True,
        #     creationflags=detached_process_flag,
        #     start_new_session=True,  # Required for some platforms
        # )

        # ahk_script = f"Run cmd.exe /c del {steam_command}"
        # steam_command_cmd = f'{steam_exe} {steam_args} {" ".join(game_args)}'
        # steam_command_cmd_quoted = f'"{steam_exe} {steam_args} {" ".join(game_args)}"'
        # steam_command_quoted = f'"{steam_command}"'
        # pristine_command = f'{steam_exe}'
        # print(f"steam command cmd: {steam_command_cmd}")
        # print(f"steam command cmd quoted: {steam_command_cmd_quoted}")
        # print(f"steam command: {steam_command}")
        # print(f"steam command quoted: {steam_command_quoted}")
        # ahk_script = f"Run cmd.exe /k del {steam_command_cmd_quoted}"
        # ahk_script = "run cmd /k E:\games\steam\steam.exe -applaunch 550 -novid -console"
        # ahk_script = f"run cmd /k {pristine_command} {steam_args}"
        # ahk_script = f"run {pristine_command} {steam_args}"
        # print(ahk_script)
        # ahk.run_script(ahk_script, blocking=False)

        # print(self.game.steam.get_exe_path())
        # subprocess.Popen(["rm", "-r", self.game.steam.get_exe_path()])

        # subprocess.Popen(['python', os.path.realpath(__file__), '0'], close_fds=True)
        # print(f'file =================================== {os.path.realpath(__file__)}')
        # subprocess.Popen(["python", self.game.steam.get_exe_path(), "0"], close_fds=True)

        # DETACHED_PROCESS = 0x00000008

        # pid = subprocess.Popen([sys.executable, "longtask.py"], creationflags=DETACHED_PROCESS).pid

        # import subprocess

        # subprocess.Popen(["notepad.exe", "test.txt"])

        # command = "longtask.py &"
        # subprocess.Popen(command, shell=True)

        # command = "start /B notepad.exe"
        # subprocess.Popen(command, shell=True)

        # command = f"start /B {self.game.steam.get_exe_path()}"
        # subprocess.Popen(command, shell=True)






















Archive:
	✔ Installer: Keep track of installation status @done(23-08-12 17:17)
	✔ Use InvalidIDError @done(23-08-12 15:55)
	✔ Use dir_mode & installation status enum's throughout the game manager @done(23-08-12 15:55)

	Game class:
		✔ Rewrite from first principles @done(23-08-16 06:00)
		
		✔ Write dir class @done(23-08-15 20:10)
		✔ Test dir class @done(23-08-15 20:10)
		✔ Write installer class @started(23-08-15 23:54) @done(23-08-16 06:00) @lasted(6h6m51s)
			✔ Write .run() & test syntax used in installer: .run(mode, wait_on_close=True) @done(23-08-16 02:39)
			✔ Refactor: wait_on_process_and_get_hwnd // probably/maybe split into 2 funcs? @done(23-08-16 02:41)
			✔ Test installer class @done(23-08-16 02:42)
			✘ Game: Still allow enabling of user mode or dev mode when the other isn't available(?) @cancelled(23-08-16 02:50)
			Nuh-uh. I need to have access to both game folders
			
			✔ Write uninstall() @done(23-08-16 03:28)
			✔ Bug: Game doesn't rebuild audio @done(23-08-16 04:27)
			✔ Bug: Editor autoexec gets appended to rather than replaced @done(23-08-16 04:27)
			✘ Installer: uninstall() when install gets cancelled or otherwise fails @cancelled(23-08-16 04:36)
			✔ Write update/repair() @done(23-08-16 04:40)
			✘ Refactor: install/update/repair has so much duplicate code! @cancelled(23-08-16 04:57)
			✔ Installer: Re-enable prompts & checks in install() & try:catch @done(23-08-16 04:58)
			
			✔ Implementation: Prompt to manually set the dev directory in hud_editing.start @done(23-08-16 05:02)
			
			✔ Write commands class @done(23-08-16 05:35)
			✔ Test commands class @done(23-08-16 05:35)
			
			✔ Centralize video settings calls into a general function @done(23-08-16 06:00)
			✔ Implementation: Replace & delete the old game instance @done(23-08-16 06:00)